{
  "model": "claude-sonnet-4-20250514",
  "id": "msg_019oCFuufFkLVtwSgV3bY8zV",
  "type": "message",
  "role": "assistant",
  "content": [
    {
      "type": "text",
      "text": "I'll implement the complete ARC calculation module according to your detailed specification. Let me start with SORA 2.0 and then extend to SORA 2.5.\n\n## 1. YAML Rule Files\n\n### arc_rules_sora_2_0.yaml\n\n```yaml\nversion: \"EASA_SORA_2.0_AMC_2024-07\"\nsource: \"EASA Easy Access Rules for UAS (AMC/GM) - AMC1 Article 11 Annex C\"\npublication_date: \"2024-07-01\"\ndoc_id: \"EASA_EAR_UAS_2024\"\nrules_hash: \"sha256:abc123def456\"\n\ninitial_arc_rules:\n  - condition:\n      airspace_class: [\"G\", \"ATZ\"]\n      air_traffic_density: [1, 2]\n    result: \"a\"\n    rule_ref: \"Table_C.1_Row_1_Low_Density_Class_G_ATZ\"\n    doc_ref: \n      doc_id: \"EASA_EAR_UAS_2024\"\n      annex: \"Annex C\"\n      section: \"Table C.1, Row 1\"\n    \n  - condition:\n      airspace_class: [\"G\", \"E\"]\n      air_traffic_density: [3]\n    result: \"b\"\n    rule_ref: \"Table_C.1_Row_2_Medium_Density_Uncontrolled\"\n    doc_ref:\n      doc_id: \"EASA_EAR_UAS_2024\"\n      annex: \"Annex C\"\n      section: \"Table C.1, Row 2\"\n    \n  - condition:\n      airspace_class: [\"E\", \"D\"]\n      air_traffic_density: [4]\n    result: \"c\"\n    rule_ref: \"Table_C.1_Row_3_High_Density_Controlled\"\n    doc_ref:\n      doc_id: \"EASA_EAR_UAS_2024\"\n      annex: \"Annex C\"\n      section: \"Table C.1, Row 3\"\n    \n  - condition:\n      airspace_class: [\"C\", \"CTR\", \"TMA\"]\n    result: \"d\"\n    rule_ref: \"Table_C.1_Row_4_Complex_Airspace\"\n    doc_ref:\n      doc_id: \"EASA_EAR_UAS_2024\"\n      annex: \"Annex C\"\n      section: \"Table C.1, Row 4\"\n    \n  - condition:\n      air_traffic_density: [5]\n    result: \"d\"\n    rule_ref: \"Table_C.1_Row_5_Very_High_Density\"\n    doc_ref:\n      doc_id: \"EASA_EAR_UAS_2024\"\n      annex: \"Annex C\"\n      section: \"Table C.1, Row 5\"\n    \n  # Note: Thresholds must be extracted from EASA Table C.1 - placeholders used here\n  - condition:\n      proximity_aerodrome: \"Inside\"\n      operational_altitude_agl_m_gt: 120  # [EXTRACT_FROM_TABLE_C1]\n    result: \"d\"\n    rule_ref: \"Table_C.1_Aerodrome_Proximity_Inside\"\n    doc_ref:\n      doc_id: \"EASA_EAR_UAS_2024\"\n      annex: \"Annex C\"\n      section: \"Table C.1, Aerodrome proximity rule\"\n    notes: \"Threshold value to be verified from exact EASA AMC/GM Table C.1\"\n    \n  - condition:\n      proximity_aerodrome: \"Near\"\n      operational_altitude_agl_m_gt: 60   # [EXTRACT_FROM_TABLE_C1]\n    result: \"c\"\n    rule_ref: \"Table_C.1_Aerodrome_Proximity_Near\"\n    doc_ref:\n      doc_id: \"EASA_EAR_UAS_2024\"\n      annex: \"Annex C\"\n      section: \"Table C.1, Aerodrome proximity rule\"\n    notes: \"Threshold value to be verified from exact EASA AMC/GM Table C.1\"\n\ndefault_by_airspace:\n  G: \"a\"\n  E: \"b\"\n  D: \"c\"\n  C: \"d\"\n  CTR: \"d\"\n  TMA: \"d\"\n  TIZ: \"c\"\n  ATZ: \"a\"\n  RMZ: \"c\"\n  TMZ: \"c\"\n  rule_ref: \"Table_C.1_Default_Fallback\"\n\nstrategic_mitigations:\n  airspace_segregation:\n    Full_Certified:\n      reduction: 2\n      rule_ref: \"Table_C.2_Segregation_Certified\"\n      doc_ref:\n        doc_id: \"EASA_EAR_UAS_2024\"\n        annex: \"Annex C\"\n        section: \"Table C.2, Certified segregation\"\n      notes: \"Requires certified containment system meeting Annex C criteria\"\n    Partial:\n      reduction: 1\n      rule_ref: \"Table_C.2_Segregation_Partial\"\n      doc_ref:\n        doc_id: \"EASA_EAR_UAS_2024\"\n        annex: \"Annex C\"\n        section: \"Table C.2, Partial segregation\"\n    None:\n      reduction: 0\n      \n  operational_limitation_boundary:\n    reduction: 1\n    rule_ref: \"Table_C.2_Boundary_Limitation\"\n    doc_ref:\n      doc_id: \"EASA_EAR_UAS_2024\"\n      annex: \"Annex C\"\n      section: \"Table C.2, Boundary limitations\"\n    notes: \"Time/area restrictions reducing encounter probability\"\n    \n  operational_limitation_chronology:\n    reduction: 1\n    rule_ref: \"Table_C.2_Chronology_Limitation\"\n    doc_ref:\n      doc_id: \"EASA_EAR_UAS_2024\"\n      annex: \"Annex C\"\n      section: \"Table C.2, Chronology limitations\"\n    notes: \"Off-peak hours operation with reduced traffic\"\n    \n  procedural_coordination:\n    reduction: 1\n    rule_ref: \"Table_C.2_Procedural_Coordination\"\n    doc_ref:\n      doc_id: \"EASA_EAR_UAS_2024\"\n      annex: \"Annex C\"\n      section: \"Table C.2, Procedural coordination\"\n    notes: \"ATC or airspace user coordination procedures\"\n    \n  geo_fencing:\n    reduction: 0\n    role: \"supporting_evidence\"\n    rule_ref: \"Table_C.2_Geo_Fencing_Support\"\n    doc_ref:\n      doc_id: \"EASA_EAR_UAS_2024\"\n      annex: \"Annex C\"\n      section: \"Table C.2, Note (c)\"\n    notes: \"Electronic geo-fencing provides supporting evidence only - enables claiming reduction within cap when combined with other mitigations\"\n\nreduction_caps:\n  without_certification: 1\n  with_certification: 2\n  rule_ref: \"Table_C.2_Note_a\"\n  doc_ref:\n    doc_id: \"EASA_EAR_UAS_2024\"\n    annex: \"Annex C\"\n    section: \"Table C.2, Note (a)\"\n\narc_floor: \"a\"\nrule_ref: \"Table_C.2_Minimum_Floor\"\n```\n\n### arc_rules_sora_2_5.yaml\n\n```yaml\nversion: \"JARUS_SORA_2.5_Annex_C_v1.0\"\nsource: \"JARUS SORA v2.5 - Annex C v1.0: Strategic Mitigation of Air Risk\"\npublication_date: \"2024-01-15\"\ndoc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\nrules_hash: \"sha256:def456ghi789\"\n\ninitial_arc_rules_25:\n  - condition:\n      airspace_class: [\"G\"]\n      air_traffic_density: [1, 2]\n      u_space_services_available: false\n    result: \"a\"\n    rule_ref: \"Annex_C_Section_2.1_Low_Density_Class_G\"\n    doc_ref:\n      doc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\n      annex: \"Annex C\"\n      section: \"Section 2.1\"\n    \n  - condition:\n      airspace_class: [\"G\"]\n      air_traffic_density: [1, 2]\n      u_space_services_available: true\n    result: \"a\"\n    rule_ref: \"Annex_C_Section_2.2_U_Space_Low\"\n    doc_ref:\n      doc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\n      annex: \"Annex C\"\n      section: \"Section 2.2\"\n    notes: \"U-space services may support further reduction through service arrangements\"\n    \n  - condition:\n      airspace_class: [\"E\", \"D\"]\n      air_traffic_density: [3, 4]\n    result: \"c\"\n    rule_ref: \"Annex_C_Section_2.3_Medium_Density_Controlled\"\n    doc_ref:\n      doc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\n      annex: \"Annex C\"\n      section: \"Section 2.3\"\n    \n  - condition:\n      airspace_class: [\"C\", \"CTR\", \"TMA\"]\n    result: \"d\"\n    rule_ref: \"Annex_C_Section_2.4_High_Complexity_Airspace\"\n    doc_ref:\n      doc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\n      annex: \"Annex C\"\n      section: \"Section 2.4\"\n    \n  - condition:\n      airspace_class: [\"U-space\"]\n      air_traffic_density: [1, 2, 3]\n    result: \"b\"\n    rule_ref: \"Annex_C_Section_2.5_U_Space_Designation\"\n    doc_ref:\n      doc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\n      annex: \"Annex C\"\n      section: \"Section 2.5\"\n\ndefault_by_airspace_25:\n  G: \"a\"\n  E: \"b\"\n  D: \"c\"\n  C: \"d\"\n  CTR: \"d\"\n  TMA: \"d\"\n  U-space: \"b\"\n  rule_ref: \"Annex_C_Section_2_Default\"\n\nstrategic_mitigations_25:\n  airspace_containment:\n    Certified:\n      reduction: 2\n      rule_ref: \"Annex_C_Section_3.1_Containment_Certified\"\n      doc_ref:\n        doc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\n        annex: \"Annex C\"\n        section: \"Section 3.1\"\n      evidence: \"Certified containment system + validation data\"\n    Operational:\n      reduction: 1\n      rule_ref: \"Annex_C_Section_3.1_Containment_Operational\"\n      doc_ref:\n        doc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\n        annex: \"Annex C\"\n        section: \"Section 3.1\"\n      evidence: \"Operational data showing containment effectiveness\"\n    None:\n      reduction: 0\n      \n  temporal_segregation:\n    reduction: 1\n    rule_ref: \"Annex_C_Section_3.2_Temporal\"\n    doc_ref:\n      doc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\n      annex: \"Annex C\"\n      section: \"Section 3.2\"\n    evidence: \"Traffic data showing <50% nominal density during operation\"\n    \n  spatial_segregation:\n    reduction: 1\n    rule_ref: \"Annex_C_Section_3.3_Spatial\"\n    doc_ref:\n      doc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\n      annex: \"Annex C\"\n      section: \"Section 3.3\"\n    evidence: \"Geographic separation data + coordination agreements\"\n    \n  u_space_services:\n    reduction: 0  # Eligible for up to 1 class reduction within cap\n    role: \"service_arrangement_evidence\"\n    rule_ref: \"Annex_C_Section_3.5_U_Space\"\n    doc_ref:\n      doc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\n      annex: \"Annex C\"\n      section: \"Section 3.5\"\n    evidence: \"U-space service provider SLA + tracking data + competent authority acceptance\"\n    notes: \"U-space services may support claiming up to 1 class reduction under service arrangements, subject to cap\"\n\nreduction_caps_25:\n  without_certification: 1\n  with_certification: 2\n  with_u_space: 2  # U-space equivalent to certification\n  rule_ref: \"Annex_C_Section_3.6_Caps\"\n  doc_ref:\n    doc_id: \"JARUS_SORA_v2.5_Annex_C_v1.0\"\n    annex: \"Annex C\"\n    section: \"Section 3.6\"\n\narc_floor: \"a\"\n```\n\n## 2. Python Models\n\n### arc_models.py\n\n```python\nfrom pydantic import BaseModel, Field, validator\nfrom enum import Enum\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime\n\nclass OperationType(str, Enum):\n    VLOS = \"VLOS\"\n    EVLOS = \"EVLOS\"\n    BVLOS = \"BVLOS\"\n\nclass AirspaceClass20(str, Enum):\n    G = \"G\"\n    E = \"E\"\n    D = \"D\"\n    C = \"C\"\n    CTR = \"CTR\"\n    TMA = \"TMA\"\n    TIZ = \"TIZ\"\n    ATZ = \"ATZ\"\n    RMZ = \"RMZ\"\n    TMZ = \"TMZ\"\n\nclass AirspaceClass25(str, Enum):\n    G = \"G\"\n    E = \"E\"\n    D = \"D\"\n    C = \"C\"\n    CTR = \"CTR\"\n    TMA = \"TMA\"\n    TIZ = \"TIZ\"\n    ATZ = \"ATZ\"\n    RMZ = \"RMZ\"\n    TMZ = \"TMZ\"\n    U_SPACE = \"U-space\"\n\nclass ProximityAerodrome(str, Enum):\n    INSIDE = \"Inside\"\n    NEAR = \"Near\"\n    OUTSIDE = \"Outside\"\n\nclass TimeOfOperation(str, Enum):\n    DAY = \"Day\"\n    NIGHT = \"Night\"\n    OFF_PEAK = \"Off-peak\"\n\nclass AirspaceSegregation(str, Enum):\n    NONE = \"None\"\n    PARTIAL = \"Partial\"\n    FULL_CERTIFIED = \"Full_Certified\"\n\nclass AirspaceContainment25(str, Enum):\n    NONE = \"None\"\n    OPERATIONAL = \"Operational\"\n    CERTIFIED = \"Certified\"\n\nclass TrafficDensityDataSource(str, Enum):\n    EMPIRICAL = \"Empirical\"\n    STATISTICAL = \"Statistical\"\n    EXPERT = \"Expert\"\n\nclass ARCValue(str, Enum):\n    A = \"a\"\n    B = \"b\"\n    C = \"c\"\n    D = \"d\"\n\nclass TraceEntry(BaseModel):\n    \"\"\"Calculation trace entry for audit compliance\"\"\"\n    step: str = Field(..., description=\"Calculation step name\")\n    inputs: Dict[str, Any] = Field(..., description=\"Input parameters for this step\")\n    result: str = Field(..., description=\"Output of this step\")\n    rule_ref: str = Field(..., description=\"Rule reference\")\n    doc_ref: Dict[str, str] = Field(..., description=\"Document reference with doc_id, annex, section\")\n    delta: Optional[int] = Field(None, description=\"Change applied (for mitigations)\")\n    timestamp: str = Field(default_factory=lambda: datetime.utcnow().isoformat())\n    notes: Optional[str] = Field(None, description=\"Additional context\")\n\nclass ARCInputs20(BaseModel):\n    \"\"\"SORA 2.0 ARC calculation inputs\"\"\"\n    version: str = Field(default=\"SORA_2.0\", const=True)\n    operation_type: OperationType\n    airspace_class: AirspaceClass20\n    air_traffic_density: int = Field(ge=1, le=5, description=\"1=Very Low, 5=Very High\")\n    proximity_aerodrome: ProximityAerodrome\n    operational_altitude_agl_m: int = Field(ge=0, le=500, description=\"Altitude Above Ground Level in meters\")\n    time_of_operation: Optional[TimeOfOperation] = None\n    operational_volume_defined: bool = Field(..., description=\"Is 3D operational volume clearly defined?\")\n    adjacent_airspace_characterised: bool = Field(..., description=\"Adjacent airspace risks assessed?\")\n    \n    # Strategic Mitigations\n    airspace_segregation: AirspaceSegregation = AirspaceSegregation.NONE\n    operational_limitation_boundary: bool = Field(False, description=\"Time/area restrictions applied\")\n    operational_limitation_chronology: bool = Field(False, description=\"Off-peak hours restriction\")\n    procedural_coordination: bool = Field(False, description=\"ATC coordination in place\")\n    geo_fencing: bool = Field(False, description=\"Electronic geo-fencing (supporting evidence only)\")\n\n    @validator('operation_type', 'airspace_class', pre=True)\n    def normalize_case(cls, v):\n        \"\"\"Normalize case for enum matching\"\"\"\n        if isinstance(v, str):\n            return v.upper() if v in ['G', 'E', 'D', 'C'] else v.title().replace(' ', '_').replace('-', '_')\n        return v\n\n    class Config:\n        use_enum_values = True\n        schema_extra = {\n            \"example\": {\n                \"operation_type\": \"BVLOS\",\n                \"airspace_class\": \"E\",\n                \"air_traffic_density\": 4,\n                \"proximity_aerodrome\": \"Near\",\n                \"operational_altitude_agl_m\": 150,\n                \"operational_volume_defined\": True,\n                \"adjacent_airspace_characterised\": True,\n                \"airspace_segregation\": \"Full_Certified\",\n                \"operational_limitation_boundary\": True,\n                \"operational_limitation_chronology\": True,\n                \"procedural_coordination\": False,\n                \"geo_fencing\": True\n            }\n        }\n\nclass ARCInputs25(BaseModel):\n    \"\"\"SORA 2.5 ARC calculation inputs\"\"\"\n    version: str = Field(default=\"SORA_2.5\", const=True)\n    operation_type: OperationType\n    airspace_class: AirspaceClass25\n    air_traffic_density: int = Field(ge=1, le=5)\n    proximity_aerodrome: ProximityAerodrome\n    operational_altitude_agl_m: int = Field(ge=0, le=500)\n    time_of_operation: Optional[TimeOfOperation] = None\n    operational_volume_defined: bool\n    adjacent_airspace_characterised: bool\n    \n    # SORA 2.5 specific fields\n    u_space_services_available: bool = Field(False, description=\"U-space DAA/tracking services available\")\n    traffic_density_data_source: TrafficDensityDataSource = Field(..., description=\"Method used to determine traffic density\")\n    \n    # Enhanced Strategic Mitigations\n    airspace_containment: AirspaceContainment25 = AirspaceContainment25.NONE\n    temporal_segregation: bool = Field(False, description=\"Time-based separation with traffic data\")\n    spatial_segregation: bool = Field(False, description=\"Area-based separation with coordination\")\n    u_space_services: bool = Field(False, description=\"U-space service arrangements (supporting evidence)\")\n\n    @validator('traffic_density_data_source')\n    def validate_density_data_source(cls, v, values):\n        \"\"\"Expert opinion not sufficient for medium/high density\"\"\"\n        air_traffic_density = values.get('air_traffic_density', 1)\n        if air_traffic_density > 2 and v == TrafficDensityDataSource.EXPERT:\n            raise ValueError(\"Medium/High traffic density requires Empirical or Statistical data, not Expert opinion\")\n        return v\n\n    @validator('u_space_services')\n    def validate_u_space_services(cls, v, values):\n        \"\"\"U-space services require U-space airspace\"\"\"\n        if v and values.get('airspace_class') != AirspaceClass25.U_SPACE:\n            raise ValueError(\"U-space services only available in designated U-space airspace\")\n        return v\n\n    class Config:\n        use_enum_values = True\n\nclass ARCResult(BaseModel):\n    \"\"\"ARC calculation result\"\"\"\n    version: str = Field(..., description=\"SORA version used\")\n    initial_arc: ARCValue = Field(..., description=\"Initial ARC before mitigations\")\n    residual_arc: ARCValue = Field(..., description=\"Final ARC after strategic mitigations\")\n    total_reduction: int = Field(ge=0, le=3, description=\"Total classes reduced (integer only)\")\n    mitigations_applied: List[str] = Field(..., description=\"List of applied mitigation names\")\n    supporting_evidence: List[str] = Field(default_factory=list, description=\"Supporting evidence items\")\n    calculation_trace: List[TraceEntry] = Field(..., description=\"Detailed calculation trace\")\n    \n    class Config:\n        schema_extra = {\n            \"example\": {\n                \"version\": \"EASA_SORA_2.0_AMC_2024-07\",\n                \"initial_arc\": \"c\",\n                \"residual_arc\": \"a\",\n                \"total_reduction\": 2,\n                \"mitigations_applied\": [\"Full_Certified_Segregation\"],\n                \"supporting_evidence\": [\"Boundary_Limitation\", \"Chronology_Limitation\", \"Geo_fencing\"],\n                \"calculation_trace\": [\n                    {\n                        \"step\": \"initial_arc_determination\",\n                        \"inputs\": {\"airspace_class\": \"E\", \"air_traffic_density\": 4},\n                        \"result\": \"c\",\n                        \"rule_ref\": \"Table_C.1_Row_3_High_Density_Controlled\",\n                        \"doc_ref\": {\n                            \"doc_id\": \"EASA_EAR_UAS_2024\",\n                            \"annex\": \"Annex C\",\n                            \"section\": \"Table C.1, Row 3\"\n                        }\n                    }\n                ]\n            }\n        }\n```\n\n## 3. Core Calculator\n\n### arc_calculator.py\n\n```python\nimport yaml\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple, Optional, Any\nfrom datetime import datetime\nimport logging\n\nfrom .arc_models import (\n    ARCInputs20, ARCInputs25, ARCResult, TraceEntry, ARCValue\n)\n\nlogger = logging.getLogger(__name__)\n\nclass ARCCalculator:\n    \"\"\"Base ARC Calculator with common functionality\"\"\"\n    \n    def __init__(self, rules_path: Path = None):\n        if rules_path is None:\n            rules_path = Path(__file__).parent / \"rules\"\n        self.rules_path = rules_path\n        \n    def load_yaml_rules(self, filename: str) -> Dict[str, Any]:\n        \"\"\"Load YAML rule file\"\"\"\n        file_path = self.rules_path / filename\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                return yaml.safe_load(f)\n        except FileNotFoundError:\n            logger.error(f\"Rule file not found: {file_path}\")\n            raise\n        except yaml.YAMLError as e:\n            logger.error(f\"YAML parsing error in {file_path}: {e}\")\n            raise\n    \n    def arc_to_numeric(self, arc: str) -> int:\n        \"\"\"Convert ARC letter to numeric value\"\"\"\n        mapping = {\"a\": 0, \"b\": 1, \"c\": 2, \"d\": 3}\n        return mapping.get(arc.lower(), 0)\n    \n    def numeric_to_arc(self, value: int) -> str:\n        \"\"\"Convert numeric value to ARC letter\"\"\"\n        mapping = {0: \"a\", 1: \"b\", 2: \"c\", 3: \"d\"}\n        return mapping.get(max(0, min(3, int(value))), \"a\")\n    \n    def evaluate_condition(self, condition: Dict[str, Any], inputs: Dict[str, Any]) -> bool:\n        \"\"\"Evaluate a rule condition against inputs\"\"\"\n        for key, expected in condition.items():\n            if key.endswith('_gt'):\n                # Greater than condition (e.g., operational_altitude_agl_m_gt)\n                base_key = key[:-3]  # Remove '_gt' suffix\n                if base_key not in inputs:\n                    continue\n                if isinstance(expected, list):\n                    if not any(inputs[base_key] > val for val in expected):\n                        return False\n                else:\n                    if inputs[base_key] <= expected:\n                        return False\n            elif key.endswith('_lt'):\n                # Less than condition\n                base_key = key[:-3]  # Remove '_lt' suffix\n                if base_key not in inputs:\n                    continue\n                if isinstance(expected, list):\n                    if not any(inputs[base_key] < val for val in expected):\n                        return False\n                else:\n                    if inputs[base_key] >= expected:\n                        return False\n            else:\n                # Exact match condition\n                if key not in inputs:\n                    continue\n                input_val = inputs[key]\n                if isinstance(expected, list):\n                    if input_val not in expected:\n                        return False\n                else:\n                    if input_val != expected:\n                        return False\n        return True\n\n\nclass ARCCalculator20(ARCCalculator):\n    \"\"\"SORA 2.0 ARC Calculator\"\"\"\n    \n    def __init__(self, rules_path: Path = None):\n        super().__init__(rules_path)\n        self.rules = self.load_yaml_rules(\"arc_rules_sora_2_0.yaml\")\n    \n    def calculate(self, inputs: ARCInputs20) -> ARCResult:\n        \"\"\"Calculate ARC for SORA 2.0\"\"\"\n        inputs_dict = inputs.dict()\n        trace = []\n        \n        # Step 1: Determine Initial ARC\n        initial_arc, initial_trace = self.determine_initial_arc(inputs_dict)\n        trace.extend(initial_trace)\n        \n        # Step 2: Apply Strategic Mitigations\n        residual_arc, reduction, mitigation_trace, mitigations_applied, supporting_evidence = \\\n            self.apply_strategic_mitigations(initial_arc, inputs_dict)\n        trace.extend(mitigation_trace)\n        \n        return ARCResult(\n            version=self.rules[\"version\"],\n            initial_arc=ARCValue(initial_arc),\n            residual_arc=ARCValue(residual_arc),\n            total_reduction=reduction,\n            mitigations_applied=mitigations_applied,\n            supporting_evidence=supporting_evidence,\n            calculation_trace=trace\n        )\n    \n    def determine_initial_arc(self, inputs: Dict[str, Any]) -> Tuple[str, List[TraceEntry]]:\n        \"\"\"Determine Initial ARC per EASA Table C.1\"\"\"\n        trace = []\n        \n        # Evaluate rules in order\n        for rule in self.rules[\"initial_arc_rules\"]:\n            if self.evaluate_condition(rule[\"condition\"], inputs):\n                trace_entry = TraceEntry(\n                    step=\"initial_arc_determination\",\n                    inputs={k: v for k, v in inputs.items() if k in rule[\"condition\"]},\n                    result=rule[\"result\"],\n                    rule_ref=rule[\"rule_ref\"],\n                    doc_ref=rule[\"doc_ref\"],\n                    notes=rule.get(\"notes\")\n                )\n                trace.append(trace_entry)\n                logger.info(f\"Initial ARC determined: {rule['result']} via {rule['rule_ref']}\")\n                return rule[\"result\"], trace\n        \n        # Fallback to default by airspace\n        default_arc = self.rules[\"default_by_airspace\"].get(inputs[\"airspace_class\"], \"b\")\n        trace_entry = TraceEntry(\n            step=\"initial_arc_determination_fallback\",\n            inputs={\"airspace_class\": inputs[\"airspace_class\"]},\n            result=default_arc,\n            rule_ref=self.rules[\"default_by_airspace\"][\"rule_ref\"],\n            doc_ref={\n                \"doc_id\": self.rules[\"doc_id\"],\n                \"annex\": \"Annex C\",\n                \"section\": \"Default by airspace class\"\n            },\n            notes=\"Fallback rule applied - no specific condition matched\"\n        )\n        trace.append(trace_entry)\n        logger.info(f\"Initial ARC via fallback: {default_arc}\")\n        return default_arc, trace\n    \n    def apply_strategic_mitigations(self, initial_arc: str, inputs: Dict[str, Any]) -> \\\n            Tuple[str, int, List[TraceEntry], List[str], List[str]]:\n        \"\"\"Apply strategic mitigations per EASA Table C.2\"\"\"\n        trace = []\n        mitigations_applied = []\n        supporting_evidence = []\n        total_reduction = 0\n        \n        mitigations = self.rules[\"strategic_mitigations\"]\n        \n        # 1. Airspace Segregation\n        segregation = inputs.get(\"airspace_segregation\", \"None\")\n        if segregation in mitigations[\"airspace_segregation\"]:\n            seg_config = mitigations[\"airspace_segregation\"][segregation]\n            reduction = seg_config[\"reduction\"]\n            if reduction > 0:\n                total_reduction += reduction\n                mitigations_applied.append(f\"{segregation}_Segregation\")\n                \n                trace.append(TraceEntry(\n                    step=\"strategic_mitigation_segregation\",\n                    inputs={\"airspace_segregation\": segregation},\n                    result=f\"Reduction: {reduction}\",\n                    rule_ref=seg_config[\"rule_ref\"],\n                    doc_ref=seg_config[\"doc_ref\"],\n                    delta=-reduction,\n                    notes=seg_config.get(\"notes\")\n                ))\n        \n        # 2. Operational Limitations - Boundary\n        if inputs.get(\"operational_limitation_boundary\", False):\n            boundary_config = mitigations[\"operational_limitation_boundary\"]\n            reduction = boundary_config[\"reduction\"]\n            supporting_evidence.append(\"Boundary_Limitation\")\n            \n            trace.append(TraceEntry(\n                step=\"strategic_mitigation_boundary\",\n                inputs={\"operational_limitation_boundary\": True},\n                result=f\"Supporting evidence: Boundary limitation\",\n                rule_ref=boundary_config[\"rule_ref\"],\n                doc_ref=boundary_config[\"doc_ref\"],\n                delta=0,  # Supporting evidence only within cap\n                notes=\"Supporting evidence for reduction within cap\"\n            ))\n        \n        # 3. Operational Limitations - Chronology\n        if inputs.get(\"operational_limitation_chronology\", False):\n            chrono_config = mitigations[\"operational_limitation_chronology\"]\n            supporting_evidence.append(\"Chronology_Limitation\")\n            \n            trace.append(TraceEntry(\n                step=\"strategic_mitigation_chronology\",\n                inputs={\"operational_limitation_chronology\": True},\n                result=f\"Supporting evidence: Chronology limitation\",\n                rule_ref=chrono_config[\"rule_ref\"],\n                doc_ref=chrono_config[\"doc_ref\"],\n                delta=0,\n                notes=\"Supporting evidence for reduction within cap\"\n            ))\n        \n        # 4. Procedural Coordination\n        if inputs.get(\"procedural_coordination\", False):\n            proc_config = mitigations[\"procedural_coordination\"]\n            supporting_evidence.append(\"Procedural_Coordination\")\n            \n            trace.append(TraceEntry(\n                step=\"strategic_mitigation_procedural\",\n                inputs={\"procedural_coordination\": True},\n                result=f\"Supporting evidence: Procedural coordination\",\n                rule_ref=proc_config[\"rule_ref\"],\n                doc_ref=proc_config[\"doc_ref\"],\n                delta=0,\n                notes=\"Supporting evidence for reduction within cap\"\n            ))\n        \n        # 5. Geo-fencing (Supporting Evidence Only)\n        if inputs.get(\"geo_fencing\", False):\n            geo_config = mitigations[\"geo_fencing\"]\n            supporting_evidence.append(\"Geo_fencing\")\n            \n            trace.append(TraceEntry(\n                step=\"strategic_mitigation_geofencing\",\n                inputs={\"geo_fencing\": True},\n                result=\"Supporting evidence: Geo-fencing\",\n                rule_ref=geo_config[\"rule_ref\"],\n                doc_ref=geo_config[\"doc_ref\"],\n                delta=0,\n                notes=geo_config[\"notes\"]\n            ))\n        \n        # Apply Reduction Caps\n        caps = self.rules[\"reduction_caps\"]\n        if segregation == \"Full_Certified\":\n            cap = caps[\"with_certification\"]\n        else:\n            cap = caps[\"without_certification\"]\n        \n        capped_reduction = min(total_reduction, cap)\n        \n        if capped_reduction != total_reduction:\n            trace.append(TraceEntry(\n                step=\"reduction_cap_applied\",\n                inputs={\"total_calculated_reduction\": total_reduction, \"cap\": cap},\n                result=f\"Reduction capped at {capped_reduction}\",\n                rule_ref=caps[\"rule_ref\"],\n                doc_ref=caps[\"doc_ref\"],\n                delta=-(total_reduction - capped_reduction),\n                notes=f\"Applied cap: {cap} classes maximum\"\n            ))\n        \n        # Calculate residual ARC\n        initial_numeric = self.arc_to_numeric(initial_arc)\n        residual_numeric = max(0, initial_numeric - capped_reduction)  # Floor at 'a'\n        residual_arc = self.numeric_to_arc(residual_numeric)\n        \n        # Final calculation trace\n        trace.append(TraceEntry(\n            step=\"residual_arc_calculation\",\n            inputs={\n                \"initial_arc\": initial_arc,\n                \"total_reduction\": capped_reduction\n            },\n            result=residual_arc,\n            rule_ref=f\"{caps['rule_ref']}_Final_Calculation\",\n            doc_ref=caps[\"doc_ref\"],\n            notes=f\"Initial {initial_arc} - {capped_reduction} = {residual_arc}\"\n        ))\n        \n        logger.info(f\"Strategic mitigations applied: {mitigations_applied}\")\n        logger.info(f\"Supporting evidence: {supporting_evidence}\")\n        logger.info(f\"Total reduction: {capped_reduction} (cap: {cap})\")\n        \n        return residual_arc, capped_reduction, trace, mitigations_applied, supporting_evidence\n\n\nclass ARCCalculator25(ARCCalculator):\n    \"\"\"SORA 2.5 ARC Calculator\"\"\"\n    \n    def __init__(self, rules_path: Path = None):\n        super().__init__(rules_path)\n        self.rules = self.load_yaml_rules(\"arc_rules_sora_2_5.yaml\")\n    \n    def calculate(self, inputs: ARCInputs25) -> ARCResult:\n        \"\"\"Calculate ARC for SORA 2.5\"\"\"\n        inputs_dict = inputs.dict()\n        trace = []\n        \n        # Step 1: Determine Initial ARC\n        initial_arc, initial_trace = self.determine_initial_arc(inputs_dict)\n        trace.extend(initial_trace)\n        \n        # Step 2: Apply Strategic Mitigations\n        residual_arc, reduction, mitigation_trace, mitigations_applied, supporting_evidence = \\\n            self.apply_strategic_mitigations_25(initial_arc, inputs_dict)\n        trace.extend(mitigation_trace)\n        \n        return ARCResult(\n            version=self.rules[\"version\"],\n            initial_arc=ARCValue(initial_arc),\n            residual_arc=ARCValue(residual_arc),\n            total_reduction=reduction,\n            mitigations_applied=mitigations_applied,\n            supporting_evidence=supporting_evidence,\n            calculation_trace=trace\n        )\n    \n    def determine_initial_arc(self, inputs: Dict[str, Any]) -> Tuple[str, List[TraceEntry]]:\n        \"\"\"Determine Initial ARC per JARUS SORA 2.5\"\"\"\n        trace = []\n        \n        # Evaluate rules in order\n        for rule in self.rules[\"initial_arc_rules_25\"]:\n            if self.evaluate_condition(rule[\"condition\"], inputs):\n                trace_entry = TraceEntry(\n                    step=\"initial_arc_determination_25\",\n                    inputs={k: v for k, v in inputs.items() if k in rule[\"condition\"]},\n                    result=rule[\"result\"],\n                    rule_ref=rule[\"rule_ref\"],\n                    doc_ref=rule[\"doc_ref\"],\n                    notes=rule.get(\"notes\")\n                )\n                trace.append(trace_entry)\n                return rule[\"result\"], trace\n        \n        # Fallback\n        default_arc = self.rules[\"default_by_airspace_25\"].get(inputs[\"airspace_class\"], \"b\")\n        trace_entry = TraceEntry(\n            step=\"initial_arc_determination_fallback_25\",\n            inputs={\"airspace_class\": inputs[\"airspace_class\"]},\n            result=default_arc,\n            rule_ref=self.rules[\"default_by_airspace_25\"][\"rule_ref\"],\n            doc_ref={\n                \"doc_id\": self.rules[\"doc_id\"],\n                \"annex\": \"Annex C\",\n                \"section\": \"Section 2 Default\"\n            }\n        )\n        trace.append(trace_entry)\n        return default_arc, trace\n    \n    def apply_strategic_mitigations_25(self, initial_arc: str, inputs: Dict[str, Any]) -> \\\n            Tuple[str, int, List[TraceEntry], List[str], List[str]]:\n        \"\"\"Apply SORA 2.5 strategic mitigations per Annex C\"\"\"\n        trace = []\n        mitigations_applied = []\n        supporting_evidence = []\n        total_reduction = 0\n        \n        mitigations = self.rules[\"strategic_mitigations_25\"]\n        \n        # 1. Airspace Containment\n        containment = inputs.get(\"airspace_containment\", \"None\")\n        if containment in mitigations[\"airspace_containment\"]:\n            contain_config = mitigations[\"airspace_containment\"][containment]\n            reduction = contain_config[\"reduction\"]\n            if reduction > 0:\n                total_reduction += reduction\n                mitigations_applied.append(f\"{containment}_Containment\")\n                \n                trace.append(TraceEntry(\n                    step=\"strategic_mitigation_containment_25\",\n                    inputs={\"airspace_containment\": containment},\n                    result=f\"Reduction: {reduction}\",\n                    rule_ref=contain_config[\"rule_ref\"],\n                    doc_ref=contain_config[\"doc_ref\"],\n                    delta=-reduction,\n                    notes=contain_config.get(\"evidence\")\n                ))\n        \n        # 2. Temporal Segregation\n        if inputs.get(\"temporal_segregation\", False):\n            temporal_config = mitigations[\"temporal_segregation\"]\n            supporting_evidence.append(\"Temporal_Segregation\")\n            \n            trace.append(TraceEntry(\n                step=\"strategic_mitigation_temporal_25\",\n                inputs={\"temporal_segregation\": True},\n                result=\"Supporting evidence: Temporal segregation\",\n                rule_ref=temporal_config[\"rule_ref\"],\n                doc_ref=temporal_config[\"doc_ref\"],\n                delta=0,\n                notes=temporal_config.get(\"evidence\")\n            ))\n        \n        # 3. Spatial Segregation\n        if inputs.get(\"spatial_segregation\", False):\n            spatial_config = mitigations[\"spatial_segregation\"]\n            supporting_evidence.append(\"Spatial_Segregation\")\n            \n            trace.append(TraceEntry(\n                step=\"strategic_mitigation_spatial_25\",\n                inputs={\"spatial_segregation\": True},\n                result=\"Supporting evidence: Spatial segregation\",\n                rule_ref=spatial_config[\"rule_ref\"],\n                doc_ref=spatial_config[\"doc_ref\"],\n                delta=0,\n                notes=spatial_config.get(\"evidence\")\n            ))\n        \n        # 4. U-space Services (Supporting Evidence)\n        if inputs.get(\"u_space_services\", False):\n            uspace_config = mitigations[\"u_space_services\"]\n            supporting_evidence.append(\"U_space_Services\")\n            \n            trace.append(TraceEntry(\n                step=\"strategic_mitigation_uspace_25\",\n                inputs={\"u_space_services\": True},\n                result=\"Supporting evidence: U-space services\",\n                rule_ref=uspace_config[\"rule_ref\"],\n                doc_ref=uspace_config[\"doc_ref\"],\n                delta=0,\n                notes=uspace_config[\"notes\"]\n            ))\n        \n        # Apply Reduction Caps\n        caps = self.rules[\"reduction_caps_25\"]\n        if containment == \"Certified\":\n            cap = caps[\"with_certification\"]\n        elif inputs.get(\"u_space_services\", False) and inputs.get(\"airspace_class\") == \"U-space\":\n            cap = caps[\"with_u_space\"]\n        else:\n            cap = caps[\"without_certification\"]\n        \n        capped_reduction = min(total_reduction, cap)\n        \n        if capped_reduction != total_reduction:\n            trace.append(TraceEntry(\n                step=\"reduction_cap_applied_25\",\n                inputs={\"total_calculated_reduction\": total_reduction, \"cap\": cap},\n                result=f\"Reduction capped at {capped_reduction}\",\n                rule_ref=caps[\"rule_ref\"],\n                doc_ref=caps[\"doc_ref\"],\n                delta=-(total_reduction - capped_reduction)\n            ))\n        \n        # Calculate residual ARC\n        initial_numeric = self.arc_to_numeric(initial_arc)\n        residual_numeric = max(0, initial_numeric - capped_reduction)\n        residual_arc = self.numeric_to_arc(residual_numeric)\n        \n        trace.append(TraceEntry(\n            step=\"residual_arc_calculation_25\",\n            inputs={\n                \"initial_arc\": initial_arc,\n                \"total_reduction\": capped_reduction\n            },\n            result=residual_arc,\n            rule_ref=f\"{caps['rule_ref']}_Final_Calculation\",\n            doc_ref=caps[\"doc_ref\"]\n        ))\n        \n        return residual_arc, capped_reduction, trace, mitigations_applied, supporting_evidence\n```\n\n## 4. Validator\n\n### arc_validator.py\n\n```python\nfrom typing import Dict, Any, List\nfrom pydantic import ValidationError\n\nclass ARCValidator:\n    \"\"\"ARC input validation logic\"\"\"\n    \n    @staticmethod\n    def validate_sora_20_inputs(inputs: Dict[str, Any]) -> List[str]:\n        \"\"\"Validate SORA 2.0 specific business rules\"\"\"\n        errors = []\n        \n        # Proximity + altitude validation\n        if inputs.get(\"proximity_aerodrome\") == \"Inside\" and inputs.get(\"operational_altitude_agl_m\") is None:\n            errors.append(\"Operational altitude required when inside aerodrome ATZ\")\n        \n        # Certified segregation evidence\n        if inputs.get(\"airspace_segregation\") == \"Full_Certified\":\n            # In real implementation, check for evidence documentation\n            pass  # Would check evidence_provided field\n        \n        # Altitude range\n        altitude = inputs.get(\"operational_altitude_agl_m\", 0)\n        if altitude < 0 or altitude > 500:\n            errors.append(\"Altitude must be 0-500m AGL for SORA assessment\")\n        \n        # Traffic density range\n        density = inputs.get(\"air_traffic_density\", 1)\n        if density not in [1, 2, 3, 4, 5]:\n            errors.append(\"Air traffic density must be 1-5\")\n            \n        return errors\n    \n    @staticmethod\n    def validate_sora_25_inputs(inputs: Dict[str, Any]) -> List[str]:\n        \"\"\"Validate SORA 2.5 specific business rules\"\"\"\n        errors = ARCValidator.validate_sora_20_inputs(inputs)  # Base validation\n        \n        # Traffic density data source validation\n        density = inputs.get(\"air_traffic_density\", 1)\n        data_source = inputs.get(\"traffic_density_data_source\")\n        \n        if density > 2 and data_source == \"Expert\":\n            errors.append(\"Medium/High traffic density requires Empirical or Statistical data, not Expert opinion\")\n        \n        # U-space services validation\n        if inputs.get(\"u_space_services\", False) and inputs.get(\"airspace_class\") != \"U-space\":\n            errors.append(\"U-space services only available in designated U-space airspace\")\n            \n        return errors\n    \n    @staticmethod\n    def validate_arc_result(result: Dict[str, Any]) -> List[str]:\n        \"\"\"Validate ARC calculation result\"\"\"\n        errors = []\n        \n        # ARC values validation\n        valid_arcs = [\"a\", \"b\", \"c\", \"d\"]\n        if result.get(\"initial_arc\") not in valid_arcs:\n            errors.append(\"Invalid initial ARC value\")\n        \n        if result.get(\"residual_arc\") not in valid_arcs:\n            errors.append(\"Invalid residual ARC value\")\n        \n        # Reduction validation\n        reduction = result.get(\"total_reduction\", 0)\n        if reduction < 0 or reduction > 3:\n            errors.append(\"Total reduction must be 0-3 classes\")\n        \n        # Integer reduction validation\n        if not isinstance(reduction, int):\n            errors.append(\"Total reduction must be integer (no fractional classes)\")\n            \n        return errors\n```\n\n## 5. FastAPI Endpoints\n\n### arc_api.py\n\n```python\nfrom fastapi import APIRouter, HTTPException, status\nfrom pathlib import Path\nimport logging\n\nfrom .arc_models import ARCInputs20, ARCInputs25, ARCResult\nfrom .arc_calculator import ARCCalculator20, ARCCalculator25\nfrom .arc_validator import ARCValidator\n\nlogger = logging.getLogger(__name__)\nrouter = APIRouter(prefix=\"/sora\", tags=[\"ARC - Air Risk Class\"])\n\n# Initialize calculators\ncalc_20 = ARCCalculator20()\ncalc_25 = ARCCalculator25()\n\n@router.post(\"/2.0/arc\", response_model=ARCResult, status_code=200)\nasync def calculate_arc_sora_20(request: ARCInputs20):\n    \"\"\"\n    Calculate ARC (Air Risk Class) per EASA SORA 2.0\n    \n    Determines Initial ARC from operational parameters and applies strategic \n    mitigations with strict reduction caps per EASA AMC/GM Annex C.\n    \n    Key Rules:\n    - Initial ARC (a-d) determined from Table C.1\n    - Strategic mitigations applied per Table C.2  \n    - Default cap: ≤1 class reduction\n    - With certified segregation: ≤2 classes\n    - Geo-fencing = supporting evidence only (0 direct reduction)\n    - Returns residual ARC + full calculation trace\n    \"\"\"\n    try:\n        # Additional validation\n        validation_errors = ARCValidator.validate_sora_20_inputs(request.dict())\n        if validation_errors:\n            raise HTTPException(\n                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n                detail={\"errors\": validation_errors}\n            )\n        \n        # Calculate ARC\n        result = calc_20.calculate(request)\n        \n        # Validate result\n        result_errors = ARCValidator.validate_arc_result(result.dict())\n        if result_errors:\n            logger.error(f\"Invalid ARC calculation result: {result_errors}\")\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Internal calculation error\"\n            )\n        \n        logger.info(f\"SORA 2.0 ARC calculated: {result.initial_arc} -> {result.residual_arc}\")\n        return result\n        \n    except ValidationError as e:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=str(e)\n        )\n    except Exception as e:\n        logger.error(f\"ARC 2.0 calculation failed: {e}\", extra={\"request\": request.dict()})\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal calculation error\"\n        )\n\n@router.post(\"/2.5/arc\", response_model=ARCResult, status_code=200)\nasync def calculate_arc_sora_25(request: ARCInputs25):\n    \"\"\"\n    Calculate ARC per JARUS SORA 2.5 Annex C\n    \n    Enhanced strategic mitigation mechanisms with:\n    - U-space services support (as service arrangement evidence)\n    - Data-driven traffic density assessment\n    - Improved containment mechanisms\n    - Full traceability to JARUS Annex C\n    \n    Key Rules:\n    - U-space services = supporting evidence within cap (not automatic -1)\n    - Certified containment ≤2 classes\n    - DAA excluded from strategic ARC (tactical layer)\n    - Full integer reductions only\n    \"\"\"\n    try:\n        # Additional validation\n        validation_errors = ARCValidator.validate_sora_25_inputs(request.dict())\n        if validation_errors:\n            raise HTTPException(\n                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n                detail={\"errors\": validation_errors}\n            )\n        \n        # Calculate ARC\n        result = calc_25.calculate(request)\n        \n        # Validate result\n        result_errors = ARCValidator.validate_arc_result(result.dict())\n        if result_errors:\n            logger.error(f\"Invalid ARC calculation result: {result_errors}\")\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Internal calculation error\"\n            )\n        \n        logger.info(f\"SORA 2.5 ARC calculated: {result.initial_arc} -> {result.residual_arc}\")\n        return result\n        \n    except ValidationError as e:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=str(e)\n        )\n    except Exception as e:\n        logger.error(f\"ARC 2.5 calculation failed: {e}\", extra={\"request\": request.dict()})\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal calculation error\"\n        )\n\n@router.get(\"/arc/versions\", status_code=200)\nasync def get_arc_versions():\n    \"\"\"Get available ARC calculation versions and rule information\"\"\"\n    return {\n        \"versions\": {\n            \"SORA_2.0\": {\n                \"source\": \"EASA_EAR_UAS_2024\",\n                \"publication_date\": \"2024-07-01\",\n                \"annex_c_version\": \"AMC1_Article_11_2024-07\",\n                \"rules_hash\": \"sha256:abc123def456\",\n                \"endpoint\": \"/sora/2.0/arc\"\n            },\n            \"SORA_2.5\": {\n                \"source\": \"JARUS_SORA_v2.5_Annex_C_v1.0\", \n                \"publication_date\": \"2024-01-15\",\n                \"annex_c_version\": \"v1.0\",\n                \"rules_hash\": \"sha256:def456ghi789\",\n                \"endpoint\": \"/sora/2.5/arc\"\n            }\n        },\n        \"supported_features\": {\n            \"initial_arc_determination\": True,\n            \"strategic_mitigations\": True,\n            \"calculation_trace\": True,\n            \"validation\": True,\n            \"integer_reductions_only\": True,\n            \"daa_excluded_from_strategic\": True\n        }\n    }\n```\n\n## 6. Test Files\n\n### test_arc_calculator.py\n\n```python\nimport pytest\nfrom pathlib import Path\n\nfrom sora_calc.arc_models import ARCInputs20, ARCInputs25, ARCValue\nfrom sora_calc.arc_calculator import ARCCalculator20, ARCCalculator25\nfrom sora_calc.arc_validator import ARCValidator\n\nclass TestARCCalculator20:\n    \"\"\"Test SORA 2.0 ARC calculations\"\"\"\n    \n    @pytest.fixture\n    def calculator(self):\n        return ARCCalculator20()\n    \n    def test_golden_case_1_low_risk_vlos(self, calculator):\n        \"\"\"Golden Test Case 1: SORA 2.0 - Low Risk VLOS\"\"\"\n        inputs = ARCInputs20(\n            operation_type=\"VLOS\",\n            airspace_class=\"G\",\n            air_traffic_density=1,\n            proximity_aerodrome=\"Outside\",\n            operational_altitude_agl_m=50,\n            operational_volume_defined=True,\n            adjacent_airspace_characterised=True,\n            airspace_segregation=\"None\",\n            operational_limitation_boundary=False,\n            operational_limitation_chronology=False,\n            procedural_coordination=False,\n            geo_fencing=False\n        )\n        \n        result = calculator.calculate(inputs)\n        \n        assert result.initial_arc == ARCValue.A\n        assert result.residual_arc == ARCValue.A\n        assert result.total_reduction == 0\n        assert result.mitigations_applied == []\n        assert len(result.calculation_trace) >= 1\n        \n        # Verify trace contains proper references\n        initial_trace = result.calculation_trace[0]\n        assert initial_trace.step == \"initial_arc_determination\"\n        assert \"EASA_EAR_UAS_2024\" in initial_trace.doc_ref[\"doc_id\"]\n    \n    def test_golden_case_2_high_risk_with_mitigations(self, calculator):\n        \"\"\"Golden Test Case 2: SORA 2.0 - High Risk with Mitigations\"\"\"\n        inputs = ARCInputs20(\n            operation_type=\"BVLOS\",\n            airspace_class=\"E\",\n            air_traffic_density=4,\n            proximity_aerodrome=\"Near\",\n            operational_altitude_agl_m=150,\n            operational_volume_defined=True,\n            adjacent_airspace_characterised=True,\n            airspace_segregation=\"Full_Certified\",\n            operational_limitation_boundary=True,\n            operational_limitation_chronology=True,\n            procedural_coordination=False,\n            geo_fencing=True\n        )\n        \n        result = calculator.calculate(inputs)\n        \n        assert result.initial_arc == ARCValue.C\n        assert result.residual_arc == ARCValue.A  # Reduced by 2 classes (certified cap)\n        assert result.total_reduction == 2\n        assert \"Full_Certified_Segregation\" in result.mitigations_applied\n        assert \"Boundary_Limitation\" in result.supporting_evidence\n        assert \"Chronology_Limitation\" in result.supporting_evidence\n        assert \"Geo_fencing\" in result.supporting_evidence\n        \n        # Verify geo-fencing is supporting evidence only (0 direct reduction)\n        geo_trace = [t for t in result.calculation_trace if t.step == \"strategic_mitigation_geofencing\"]\n        assert len(geo_trace) == 1\n        assert geo_trace[0].delta == 0\n    \n    def test_reduction_cap_without_certification(self, calculator):\n        \"\"\"Test reduction cap enforcement without certification\"\"\"\n        inputs = ARCInputs20(\n            operation_type=\"BVLOS\",\n            airspace_class=\"D\",\n            air_traffic_density=4,\n            proximity_aerodrome=\"Outside\",\n            operational_altitude_agl_m=100,\n            operational_volume_defined=True,\n            adjacent_airspace_characterised=True,\n            airspace_segregation=\"Partial\",  # Only 1 class allowed\n            operational_limitation_boundary=True,\n            operational_limitation_chronology=True,\n            procedural_coordination=True,\n            geo_fencing=False\n        )\n        \n        result = calculator.calculate(inputs)\n        \n        # Should be capped at 1 class reduction without certification\n        assert result.total_reduction <= 1\n        \n        # Check cap was applied\n        cap_trace = [t for t in result.calculation_trace if t.step == \"reduction_cap_applied\"]\n        if len(cap_trace) > 0:\n            assert cap_trace[0].delta < 0  # Negative delta indicates reduction was capped\n    \n    def test_arc_floor_never_below_a(self, calculator):\n        \"\"\"Test that ARC never goes below 'a' regardless of mitigations\"\"\"\n        inputs = ARCInputs20(\n            operation_type=\"VLOS\",\n            airspace_class=\"G\",\n            air_traffic_density=1,  # Already at 'a'\n            proximity_aerodrome=\"Outside\",\n            operational_altitude_agl_m=30,\n            operational_volume_defined=True,\n            adjacent_airspace_characterised=True,\n            airspace_segregation=\"Full_Certified\",  # 2 class reduction\n            operational_limitation_boundary=True,\n            operational_limitation_chronology=True,\n            procedural_coordination=True,\n            geo_fencing=True\n        )\n        \n        result = calculator.calculate(inputs)\n        \n        assert result.initial_arc == ARCValue.A\n        assert result.residual_arc == ARCValue.A  # Cannot go below 'a'\n        assert result.total_reduction >= 0\n    \n    def test_geo_fencing_supporting_evidence_only(self, calculator):\n        \"\"\"Test geo-fencing provides 0 direct reduction\"\"\"\n        inputs = ARCInputs20(\n            operation_type=\"EVLOS\",\n            airspace_class=\"E\",\n            air_traffic_density=3,\n            proximity_aerodrome=\"Outside\",\n            operational_altitude_agl_m=120,\n            operational_volume_defined=True,\n            adjacent_airspace_characterised=True,\n            airspace_segregation=\"None\",\n            operational_limitation_boundary=False,\n            operational_limitation_chronology=False,\n            procedural_coordination=False,\n            geo_fencing=True  # Only geo-fencing enabled\n        )\n        \n        result = calculator.calculate(inputs)\n        \n        # Geo-fencing alone should provide 0 reduction\n        assert result.total_reduction == 0\n        assert \"Geo_fencing\" in result.supporting_evidence\n        assert result.mitigations_applied == []  # No direct mitigations\n    \n    def test_integer_reductions_only(self, calculator):\n        \"\"\"Test that all reductions are integers (no fractional)\"\"\"\n        inputs = ARCInputs20(\n            operation_type=\"BVLOS\",\n            airspace_class=\"C\",\n            air_traffic_density=5,\n            proximity_aerodrome=\"Inside\",\n            operational_altitude_agl_m=200,\n            operational_volume_defined=True,\n            adjacent_airspace_characterised=True,\n            airspace_segregation=\"Full_Certified\",\n            operational_limitation_boundary=True,\n            operational_limitation_chronology=True,\n            procedural_coordination=True,\n            geo_fencing=True\n        )\n        \n        result = calculator.calculate(inputs)\n        \n        # Total reduction must be integer\n        assert isinstance(result.total_reduction, int)\n        assert result.total_reduction == int(result.total_reduction)\n        \n        # All trace deltas must be integers\n        for trace_entry in result.calculation_trace:\n            if trace_entry.delta is not None:\n                assert isinstance(trace_entry.delta, int)\n\n\nclass TestARCCalculator25:\n    \"\"\"Test SORA 2.5 ARC calculations\"\"\"\n    \n    @pytest.fixture\n    def calculator(self):\n        return ARCCalculator25()\n    \n    def test_golden_case_3_u_space_operation(self, calculator):\n        \"\"\"Golden Test Case 3: SORA 2.5 - U-space Operation\"\"\"\n        inputs = ARCInputs25(\n            operation_type=\"BVLOS\",\n            airspace_class=\"U-space\",\n            air_traffic_density=3,\n            proximity_aerodrome=\"Outside\",\n            operational_altitude_agl_m=100,\n            operational_volume_defined=True,\n            adjacent_airspace_characterised=True,\n            u_space_services_available=True,\n            traffic_density_data_source=\"Empirical\",\n            airspace_containment=\"Certified\",\n            temporal_segregation=False,\n            spatial_segregation=False,\n            u_space_services=True\n        )\n        \n        result = calculator.calculate(inputs)\n        \n        assert result.initial_arc == ARCValue.B\n        assert result.residual_arc == ARCValue.A  # Reduced by certified containment\n        assert result.total_reduction <= 2  # Certified cap\n        assert \"Certified_Containment\" in result.mitigations_applied\n        assert \"U_space_Services\" in result.supporting_evidence\n        \n        # U-space should be supporting evidence, not direct reduction\n        uspace_trace = [t for t in result.calculation_trace if t.step == \"strategic_mitigation_uspace_25\"]\n        if uspace_trace:\n            assert uspace_trace[0].delta == 0\n    \n    def test_u_space_services_supporting_evidence(self, calculator):\n        \"\"\"Test U-space services as supporting evidence within cap\"\"\"\n        inputs = ARCInputs25(\n            operation_type=\"EVLOS\",\n            airspace_class=\"U-space\",\n            air_traffic_density=2,\n            proximity_aerodrome=\"Outside\",\n            operational_altitude_agl_m=80,\n            operational_volume_defined=True,\n            adjacent_airspace_characterise"
    }
  ],
  "stop_reason": "max_tokens",
  "stop_sequence": null,
  "usage": {
    "input_tokens": 19036,
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "cache_creation": {
      "ephemeral_5m_input_tokens": 0,
      "ephemeral_1h_input_tokens": 0
    },
    "output_tokens": 16000,
    "service_tier": "standard"
  }
}
