# SKYWORKS AI SUITE - CRITICAL TABLE 2 ANALYSIS REQUEST

**Analysis Date:** 2025-10-29 20:51:06
**Priority:** HIGH - Blocking accurate SORA calculations
**Requester:** SKYWORKS Development Team via GitHub Copilot

---

## PROBLEM SUMMARY

The SKYWORKS AI Suite has two different implementations of "JARUS SORA Table 2":

1. **Python Backend**: Uses SORA 2.0 MTOM-based 5×4 matrix
2. **.NET Backend**: Uses JARUS SORA 2.5 Dimension+Speed-based 7×5 matrix

This causes calculation discrepancies and test failures. We need your expert analysis to:

1. Identify which Table 2 belongs to which SORA version (from official JARUS docs)
2. Determine if both backends are correct (for their respective versions)
3. Provide specific code fixes with exact line numbers
4. Recommend implementation strategy (dual support vs migration)

---

## DETAILED ANALYSIS REQUEST

# CRITICAL ANALYSIS REQUEST FOR CLAUDE SONNET 4

## PROBLEM SUMMARY

The Python backend (`Backend_Python/main.py`) implements **SORA 2.0 Table 2** (MTOM-based matrix), but the .NET backend reference documentation (`Backend/JARUS_25_TABLE2_REFERENCE.ps1`) shows **JARUS SORA 2.5 Table 2** (Dimension+Speed-based matrix).

**These are TWO COMPLETELY DIFFERENT tables with different structures and values.**

## CURRENT PYTHON IMPLEMENTATION (Backend_Python/main.py lines 32-50)

```python
# Table 2: Initial GRC Matrix (AUTHORITATIVE - JARUS SORA 2.5 Annex A)
# Population Density →  ≤1/km²  ≤500   ≤10k   >10k
# MTOM Category ↓      (Cat 0) (Cat 1)(Cat 2)(Cat 3)
IGRC_MATRIX = [
    [1, 2, 3, 4],  # Category 0 (<0.25kg)
    [1, 2, 4, 5],  # Category 1 (0.25-1kg)  
    [2, 3, 5, 6],  # Category 2 (1-25kg)
    [3, 4, 6, 7],  # Category 3 (25-150kg)
    [4, 5, 7, 8]   # Category 4 (>150kg)
]

@staticmethod
def get_population_category(population_density: int) -> int:
    """Get population density category per JARUS SORA Table 2"""
    if population_density <= 1:
        return 0  # Controlled ground area
    elif population_density <= 500:
        return 1  # Sparsely populated
    elif population_density <= 10000:
        return 2  # Moderately populated  
    else:
        return 3  # High density populated (>10k/km²)
```

**This is SORA 2.0 structure: 5×4 matrix based on MTOM weight categories**

## OFFICIAL JARUS SORA 2.5 TABLE 2 (Backend/JARUS_25_TABLE2_REFERENCE.ps1)

```
## POPULATION DENSITY CATEGORIES (Rows):
# Row 0: Controlled ground area (special management)
# Row 1: < 5 people/km² (Remote)
# Row 2: ≥5 and <50 (Lightly populated)
# Row 3: ≥50 and <500 (Sparsely populated)  
# Row 4: ≥500 and <5,000 (Suburban)
# Row 5: ≥5,000 and <50,000 (High density metro)
# Row 6: ≥50,000 (Assemblies of people)

## UA DIMENSION + SPEED CATEGORIES (Columns):
# Column 0: ≤1m AND ≤25 m/s (Small)
# Column 1: ≤3m AND ≤35 m/s (Medium)
# Column 2: ≤8m AND ≤75 m/s (Large)
# Column 3: ≤20m AND ≤120 m/s (Very Large)
# Column 4: >20m OR >120 m/s (Extra Large)

## JARUS 2.5 TABLE 2 MATRIX:
#             Col0  Col1  Col2  Col3  Col4
#           (1m/  (3m/  (8m/  (20m/ (40m+/
#            25)   35)   75)   120)  200+)
# Row 0 (Controlled)  1     1     2     3     3
# Row 1 (<5)          2     3     4     5     6
# Row 2 (<50)         3     4     5     6     7
# Row 3 (<500)        4     5     6     7     8
# Row 4 (<5k)         5     6     7     8     9
# Row 5 (<50k)        6     7     8     9    10
# Row 6 (≥50k)        7     8    GREY  GREY  GREY

## SPECIAL RULES:
# 1. ≤250g MTOM AND ≤25m/s → ALWAYS iGRC=1 (overrides table)
# 2. Grey cells (Row 6, Col 2-4) = Out of SORA 2.5 scope
```

**This is SORA 2.5 structure: 7×5 matrix based on Dimension + Speed**

## KEY DIFFERENCES

| Aspect | SORA 2.0 (Current Python) | JARUS SORA 2.5 (Reference) |
|--------|---------------------------|----------------------------|
| **Matrix Size** | 5 rows × 4 columns | 7 rows × 5 columns |
| **Row Basis** | MTOM weight categories | Population density (7 levels) |
| **Column Basis** | Population density (4 levels) | UA Dimension + Speed (5 levels) |
| **Population Boundaries** | ≤1, ≤500, ≤10k, >10k | <5, <50, <500, <5k, <50k, ≥50k |
| **Max iGRC** | 8 | 10 |
| **Special Rules** | None | ≤250g + ≤25m/s → iGRC=1 |

## EVIDENCE OF CONFUSION

**Test #4 Failure:**
```
Test 4: Small Drone (0.8kg), Suburban (8000 ppl/km²)
Expected iGRC=5, Got=4 FAIL
```

**Why it failed:**
- In **SORA 2.5**: 8000 ppl/km² is Row 5 (≥5k and <50k), not Row 4
- In **SORA 2.0**: 8000 ppl/km² is Category 2 (≤10k), MTOM 0.8kg is Category 1
- Result: IGRC_MATRIX[1][2] = 4 ✓ (SORA 2.0 correct)
- But expected 5 because test was written for SORA 2.5 logic

## FILES TO ANALYZE

### Python Backend Files (SORA 2.0 implementation)
1. `Backend_Python/main.py` - Lines 30-92 (JARUSSORATable2 class)
2. `Backend_Python/calculations/grc_calculator.py` - GRC calculation logic
3. `Backend_Python/models/sora_models.py` - Data models

### .NET Backend Files (SORA 2.5 reference)
1. `Backend/src/Skyworks.Core/Services/GRC/GRCCalculationService.cs`
2. `Backend/JARUS_25_TABLE2_REFERENCE.ps1`
3. `Backend/ACCURACY_TEST_REPORT.md`

### Official Documentation (Need to verify)
- JARUS SORA 2.0 Annex A (if available)
- JARUS SORA 2.5 Annex A Table 2 (JAR-DEL-SRM-SORA-MB-2.5)

## QUESTIONS FOR CLAUDE SONNET 4

### 1. Which Table 2 is correct for each SORA version?
- Does SORA 2.0 use MTOM-based Table 2?
- Does SORA 2.5 use Dimension+Speed-based Table 2?
- Or are they both valid but for different use cases?

### 2. Should Python backend support BOTH versions?
- Should there be two separate calculation paths?
- `/api/v1/calculate/grc/2.0` → MTOM-based Table 2
- `/api/v1/calculate/grc/2.5` → Dimension+Speed-based Table 2

### 3. Are the .NET and Python backends supposed to be identical?
- Currently they implement different Table 2 structures
- Is this intentional (different versions) or a bug?

### 4. What is the migration path?
If SORA 2.5 replaces 2.0:
- Should we deprecate MTOM-based calculations?
- Do we need backward compatibility?
- What about existing missions calculated with SORA 2.0?

## ANALYSIS METHODOLOGY REQUEST

Please analyze this systematically:

### Step 1: Document Review
1. Read official JARUS SORA 2.0 documentation
2. Read official JARUS SORA 2.5 documentation (JAR-DEL-SRM-SORA-MB-2.5)
3. Compare Table 2 structures in both versions
4. Document which structure belongs to which version

### Step 2: Code Analysis
1. Read `Backend_Python/main.py` (full file)
2. Read `Backend/src/Skyworks.Core/Services/GRC/GRCCalculationService.cs`
3. Identify which SORA version each backend implements
4. Document discrepancies

### Step 3: Test Case Validation
1. For each test case, determine if it's testing SORA 2.0 or 2.5
2. Verify expected values against correct Table 2
3. Identify which tests are using wrong expected values

### Step 4: Recommendation
Provide ONE of these solutions:

**Option A: Separate Implementations**
- Keep SORA 2.0 with MTOM-based Table 2
- Add SORA 2.5 with Dimension+Speed-based Table 2
- Support both via different endpoints

**Option B: Migrate to SORA 2.5 Only**
- Replace MTOM-based Table 2 with Dimension+Speed-based
- Update all calculations to JARUS 2.5 standards
- Deprecate SORA 2.0 support

**Option C: Fix Current Implementation**
- Current Python code is correct for SORA 2.0
- Tests are wrong (expecting SORA 2.5 values)
- Just fix test expectations

## EXPECTED DELIVERABLES

1. **Table 2 Specification Document** - Which table belongs to which SORA version
2. **Code Fix Recommendations** - Specific file changes with line numbers
3. **Updated Test Suite** - Correct expected values for each SORA version
4. **Migration Guide** - If changes needed, how to implement without breaking existing functionality

## URGENCY

**HIGH** - This is blocking accurate GRC calculations. Current system may be calculating wrong values if wrong Table 2 is used.

---

**Analysis Date:** October 29, 2025  
**Requester:** SKYWORKS AI Suite Development Team  
**Target Reviewer:** Claude Sonnet 4 (Visual Studio Integrated)


---

## CURRENT PYTHON IMPLEMENTATION (Backend_Python/main.py)

```python
"""
SKYWORKS AI SUITE - FastAPI Main Entry Point
Python microservice for SORA calculations
"""

import logging
from typing import Any, Dict, List
from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.exceptions import RequestValidationError
from pydantic import ValidationError
import json

from models.sora_models import (
    GRCRequest_2_0,
    GRCRequest_2_5,
    GRCResponse,
    ARCRequest_2_0,
    ARCRequest_2_5,
    ARCResponse,
    SAILRequest,
    SAILResponse,
)
from calculations.grc_calculator import GRCCalculator
from calculations.arc_calculator import ARCCalculator
from calculations.sail_calculator import SAILCalculator

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ===== JARUS SORA Table 2 - Unified Implementation =====
class JARUSSORATable2:
    """Official JARUS SORA Table 2 implementation for both 2.0 and 2.5"""
    
    # Table 2: Initial GRC Matrix (AUTHORITATIVE - JARUS SORA 2.5 Annex A)
    # Population Density →  ≤1/km²  ≤500   ≤10k   >10k
    # MTOM Category ↓      (Cat 0) (Cat 1)(Cat 2)(Cat 3)
    IGRC_MATRIX = [
        [1, 2, 3, 4],  # Category 0 (<0.25kg)
        [1, 2, 4, 5],  # Category 1 (0.25-1kg)  
        [2, 3, 5, 6],  # Category 2 (1-25kg)
        [3, 4, 6, 7],  # Category 3 (25-150kg)
        [4, 5, 7, 8]   # Category 4 (>150kg)
    ]
    
    @staticmethod
    def get_mtom_category(mtom_kg: float) -> int:
        """Get MTOM category per JARUS SORA Table 2"""
        if mtom_kg < 0.25:
            return 0
        elif mtom_kg < 1:
            return 1
        elif mtom_kg < 25:
            return 2
        elif mtom_kg < 150:
            return 3
        else:
            return 4
    
    @staticmethod
    def get_population_category(population_density: int) -> int:
        """Get population density category per JARUS SORA Table 2"""
        if population_density <= 1:
            return 0  # Controlled ground area
        elif population_density <= 500:
            return 1  # Sparsely populated
        elif population_density <= 10000:
            return 2  # Moderately populated  
        else:
            return 3  # High density populated (>10k/km²)
    
    @staticmethod
    def calculate_initial_grc(mtom_kg: float, population_density: int) -> Dict[str, Any]:
        """Calculate initial GRC using official JARUS SORA Table 2"""
        mtom_category = JARUSSORATable2.get_mtom_category(mtom_kg)
        pop_category = JARUSSORATable2.get_population_category(population_density)
        
        initial_grc = JARUSSORATable2.IGRC_MATRIX[mtom_category][pop_category]
        
        return {
            "initial_grc": initial_grc,
            "mtom_category": mtom_category,
            "population_category": pop_category,
            "calculation_method": "JARUS_SORA_TABLE_2",
            "debug_info": {
                "mtom_kg": mtom_kg,
                "population_density": population_density
```

[Full file: 617 lines - see attached]

---

## OFFICIAL JARUS SORA 2.5 REFERENCE (Backend/JARUS_25_TABLE2_REFERENCE.ps1)

```powershell
# OFFICIAL JARUS SORA 2.5 TABLE 2 REFERENCE CARD
# ================================================
# Use this as ground truth for all iGRC calculations

## POPULATION DENSITY CATEGORIES (Rows):
#
# Row 0: Controlled ground area (special management)
# Row 1: < 5 people/km² (Remote)
# Row 2: ≥5 and <50 (Lightly populated)
# Row 3: ≥50 and <500 (Sparsely populated)  
# Row 4: ≥500 and <5,000 (Suburban)
# Row 5: ≥5,000 and <50,000 (High density metro)
# Row 6: ≥50,000 (Assemblies of people)

## UA DIMENSION + SPEED CATEGORIES (Columns):
#
# Column 0: ≤1m AND ≤25 m/s (Small)
# Column 1: ≤3m AND ≤35 m/s (Medium)
# Column 2: ≤8m AND ≤75 m/s (Large)
# Column 3: ≤20m AND ≤120 m/s (Very Large)
# Column 4: >20m OR >120 m/s (Extra Large)

## JARUS 2.5 TABLE 2 MATRIX:
#
#             Col0  Col1  Col2  Col3  Col4
#           (1m/  (3m/  (8m/  (20m/ (40m+/
#            25)   35)   75)   120)  200+)
# Row 0 (Controlled)  1     1     2     3     3
# Row 1 (<5)          2     3     4     5     6
# Row 2 (<50)         3     4     5     6     7
# Row 3 (<500)        4     5     6     7     8
# Row 4 (<5k)         5     6     7     8     9
# Row 5 (<50k)        6     7     8     9    10
# Row 6 (≥50k)        7     8    GREY  GREY  GREY

## SPECIAL RULES:
#
# 1. ≤250g MTOM AND ≤25m/s → ALWAYS iGRC=1 (overrides table)
# 2. Grey cells (Row 6, Col 2-4) = Out of SORA 2.5 scope
# 3. BOTH dimension AND speed must satisfy column criteria

## EXAMPLES:
#
# - 0.2m, 20m/s, 50 ppl/km² → Small (0.2≤1 AND 20≤25), Row 2 → iGRC=3
# - 3.0m, 35m/s, 500 ppl/km² → Medium (3≤3 AND 35≤35), Row 4 → iGRC=6 ✅
# - 3.0m, 40m/s, 500 ppl/km² → Large (40>35, fail Med), Row 4 → iGRC=7
# - 8.0m, 75m/s, 2000 ppl/km² → Large (8≤8 AND 75≤75), Row 4 → iGRC=7 ✅
# - 20m, 120m/s, 5 ppl/km² → VeryLarge (20≤20 AND 120≤120), Row 1 → iGRC=5 ✅

## MITIGATION CREDITS (JARUS 2.5):
#
# M1(A) - Sheltering:
#   - Low: -1
#   - Medium: -2
#
# M1(B) - Operational restrictions:
#   - Medium: -1
#   - High: -2
#
# M1(C) - Ground observation:
#   - Low: -1
#
# M2 - Impact dynamics (parachute):
#   - Medium: -1
#   - High: -2
#
# VALIDATION RULES:
# - M1A Medium + M1B ANY = INVALID (Annex B)
# - Final GRC ≥1 (floor)
# - Final GRC ≤7 (SORA 2.5 scope limit)

Write-Host "JARUS SORA 2.5 TABLE 2 REFERENCE LOADED" -ForegroundColor Green

```

---

## TEST SHOWING THE PROBLEM (test_sora_direct.py)

Test #4 fails:
- Input: 0.8kg drone, 8000 ppl/km²
- Expected: iGRC=5 (based on SORA 2.5 logic)
- Got: iGRC=4 (Python returns SORA 2.0 result)

```python
#!/usr/bin/env python3
"""
SKYWORKS AI SUITE - Direct SORA Validation Tests
Tests calculations directly without HTTP server
"""

import sys
import os

# Add Backend_Python to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'Backend_Python'))

from main import JARUSSORATable2, SORA_20_MITIGATIONS, SORA_25_MITIGATIONS
from calculations.sail_calculator import SAILCalculator
from models.sora_models import SAILRequest, ARCRating

# Initialize
sail_calc = SAILCalculator()

# Test results
total_tests = 0
passed_tests = 0
failed_tests = []

def test_grc(test_num, test_name, mtom_kg, pop_density, expected_igrc):
    """Test GRC calculation"""
    global total_tests, passed_tests
    total_tests += 1
    
    result = JARUSSORATable2.calculate_initial_grc(mtom_kg, pop_density)
    actual_igrc = result['initial_grc']
    
    if actual_igrc == expected_igrc:
        passed_tests += 1
        print(f"✅ Test {test_num}: {test_name} - iGRC={actual_igrc} PASS")
        return True
    else:
        print(f"❌ Test {test_num}: {test_name} - Expected iGRC={expected_igrc}, Got={actual_igrc} FAIL")
        failed_tests.append((test_num, test_name, f"Expected iGRC={expected_igrc}, Got={actual_igrc}"))
        return False

def test_sail(test_num, test_name, final_grc, residual_arc_str, expected_sail):
    """Test SAIL calculation"""
    global total_tests, passed_tests
    total_tests += 1
    
    # Convert string to enum
    arc_map = {
        "ARC-a": ARCRating.ARC_a,
        "ARC-b": ARCRating.ARC_b,
        "ARC-c": ARCRating.ARC_c,
        "ARC-d": ARCRating.ARC_d
    }
    residual_arc = arc_map[residual_arc_str]
    
    request = SAILRequest(final_grc=final_grc, residual_arc=residual_arc)
    result = sail_calc.calculate_sail(request)
    actual_sail = result.sail
    
    if actual_sail == expected_sail:
        passed_tests += 1
        print(f"✅ Test {test_num}: {test_name} - SAIL={actual_sail} PASS")
        return True
    else:
        print(f"❌ Test {tes
```

---

## COLLABORATION GUIDE

# HOW TO COLLABORATE WITH CLAUDE SONNET 4 - SKYWORKS SORA TABLE 2 FIX

## OVERVIEW

This document explains how GitHub Copilot and Claude Sonnet 4 can collaborate to fix the SORA Table 2 discrepancy in SKYWORKS AI Suite.

## THE PROBLEM

**Two different "Table 2" implementations exist:**

1. **Python Backend** (`Backend_Python/main.py`): Uses SORA 2.0 MTOM-based 5×4 matrix
2. **.NET Backend** (`Backend/`): Uses JARUS SORA 2.5 Dimension+Speed-based 7×5 matrix

**This causes calculation discrepancies and test failures.**

## COLLABORATION WORKFLOW

### Phase 1: Information Gathering (Copilot)

**Copilot's role:**
1. ✅ Collect all relevant files
2. ✅ Create comprehensive problem statement
3. ✅ Package context for Sonnet 4

**Files to send to Sonnet 4:**

#### Core Problem Document
- `SONNET_TABLE2_ANALYSIS_REQUEST.md` (this analysis request)

#### Python Backend Files
- `Backend_Python/main.py` (lines 30-92 - JARUSSORATable2 class)
- `Backend_Python/calculations/grc_calculator.py` (full file)
- `Backend_Python/models/sora_models.py` (SORA data models)
- `Backend_Python/main.py` (lines 250-400 - GRC 2.0 and 2.5 endpoints)

#### .NET Backend Files  
- `Backend/JARUS_25_TABLE2_REFERENCE.ps1` (official SORA 2.5 Table 2)
- `Backend/ACCURACY_TEST_REPORT.md` (test results showing 100% pass on .NET)
- `Backend/src/Skyworks.Core/Services/GRC/GRCCalculationService.cs` (if exists)

#### Documentation Files
- `ACCURACY_TEST_REPORT.md`
- `COMPREHENSIVE_ACCURACY_REPORT.md`
- `Docs/Compliance/SKYWORKS_SORA_COMPLIANCE_AUDIT_REPORT.md` (lines 325-347)

#### Test Files
- `test_sora_direct.py` (our failed test showing the problem)
- `COMPREHENSIVE_SORA_VALIDATION_TEST.ps1` (PowerShell tests)

### Phase 2: Sonnet 4 Analysis

**Sonnet 4's role:**
1. Read all official JARUS documentation
2. Identify which Table 2 belongs to which SORA version
3. Analyze code discrepancies
4. Provide specific fix recommendations

**Expected Sonnet 4 deliverables:**

```markdown
1. TABLE 2 SPECIFICATION DOCUMENT
   - SORA 2.0 Table 2 structure (from official docs)
   - JARUS SORA 2.5 Table 2 structure (from official docs)
   - Key differences documented

2. CODE ANALYSIS REPORT
   - Which backend implements which version correctly
   - Line-by-line code review with corrections
   - Specific file paths and line numbers to change

3. RECOMMENDED SOLUTION
   One of:
   - Option A: Separate implementations (keep both)
   - Option B: Migrate to SORA 2.5 only
   - Option C: Fix tests (code is correct)

4. IMPLEMENTATION PLAN
   - Step-by-step migration guide
   - Code changes with before/after
   - Updated test expectations
```

### Phase 3: Implementation (Copilot)

**Copilot receives Sonnet 4's response and:**
1. Reads the analysis report
2. Implements recommended code changes
3. Updates test expectations
4. Re-runs validation tests
5. Verifies 100% pass rate

## HOW TO SEND TO SONNET 4

### Method 1: VS Code Integrated (Recommended)

```
1. Open new Claude Sonnet 4 chat in VS Code
2. Attach these files:
   - SONNET_TABLE2_ANALYSIS_REQUEST.md
   - Backend_Python/main.py
   - Backend/JARUS_25_TABLE2_REFERENCE.ps1
   - test_sora_direct.py
   
3. Send message:
   "@SONNET_TABLE2_ANALYSIS_REQUEST.md Please analyze this 
   SORA Table 2 discrepancy and provide detailed fix recommendations 
   per the analysis methodology in the document."
```

### Method 2: Claude.ai Web Interface

```
1. Copy content of SONNET_TABLE2_ANALYSIS_REQUEST.md
2. Attach relevant files (main.py, reference files, tests)
3. Paste analysis request
4. Wait for comprehensive response
5. Copy response back to VS Code
```

### Method 3: API Integration (Advanced)

```python
# send_to_sonnet4.py
import anthropic

client = anthropic.Anthropic(api_key="YOUR_KEY")

with open("SONNET_TABLE2_ANALYSIS_REQUEST.md") as f:
    analysis_request = f.read()

response = client.messages.create(
    model="claude-sonnet-4-20250514",
    max_tokens=8192,
    messages=[{
        "role": "user",
        "content": analysis_request
    }]
)

with open("SONNET4_RESPONSE_TABLE2.md", "w") as f:
    f.write(response.content[0].text)
```

## EXPECTED SONNET 4 RESPONSE FORMAT

```markdown
# SONNET 4 ANALYSIS: SKYWORKS SORA TABLE 2 FIX

## 1. OFFICIAL SPECIFICATION VERIFICATION

### SORA 2.0 Table 2 (EASA AMC)
**Source:** EASA AMC1 UAS.OPEN.040/050/060 Annex
**Structure:** 5 rows (MTOM categories) × 4 columns (population density)
**Matrix:**
[Exact table from official docs]

### JARUS SORA 2.5 Table 2 (JAR-DEL-SRM-SORA-MB-2.5)
**Source:** JARUS SORA 2.5 Main Body Section 2.3, Table 2
**Structure:** 7 rows (population density) × 5 columns (dimension+speed)
**Matrix:**
[Exact table from official docs]

## 2. CODE ANALYSIS

### Python Backend (Backend_Python/main.py)
**Current Implementation:** SORA 2.0 MTOM-based
**Correctness:** ✅ CORRECT for SORA 2.0 / ❌ INCORRECT for SORA 2.5

**Issues Found:**
- Line 12: Comment says "JARUS SORA 2.5" but implements SORA 2.0
- Line 38-45: Population boundaries are SORA 2.0 (≤1, ≤500, ≤10k, >10k)
- Missing: SORA 2.5 dimension+speed logic

### .NET Backend (Backend/...)
**Current Implementation:** JARUS SORA 2.5 Dimension+Speed-based
**Correctness:** ✅ CORRECT for SORA 2.5

## 3. RECOMMENDED SOLUTION

**OPTION A: Dual Implementation (RECOMMENDED)**

Reason: Both SORA versions are valid and in use. Support both.

### Implementation Steps:

1. **Rename existing Python class:**
   ```python
   # main.py line 32
   class SORAv2_0_Table2:  # Rename from JARUSSORATable2
       """SORA 2.0 MTOM-based Table 2 (EASA AMC)"""
   ```

2. **Create new SORA 2.5 class:**
   ```python
   class JARUSSORAv2_5_Table2:
       """JARUS SORA 2.5 Dimension+Speed-based Table 2"""
       
       IGRC_MATRIX = [
           [1, 1, 2, 3, 3],  # Row 0: Controlled
           [2, 3, 4, 5, 6],  # Row 1: <5 ppl/km²
           [3, 4, 5, 6, 7],  # Row 2: <50
           [4, 5, 6, 7, 8],  # Row 3: <500
           [5, 6, 7, 8, 9],  # Row 4: <5k
           [6, 7, 8, 9, 10], # Row 5: <50k
           [7, 8, -1, -1, -1] # Row 6: ≥50k (grey cells)
       ]
       
       @staticmethod
       def get_dimension_speed_category(dimension_m, speed_ms):
           if dimension_m <= 1 and speed_ms <= 25:
               return 0
           elif dimension_m <= 3 and speed_ms <= 35:
               return 1
           elif dimension_m <= 8 and speed_ms <= 75:
               return 2
           elif dimension_m <= 20 and speed_ms <= 120:
               return 3
           else:
               return 4
       
       @staticmethod
       def get_population_category_2_5(population_density):
           if population_density < 5:
               return 1
           elif population_density < 50:
               return 2
           elif population_density < 500:
               return 3
           elif population_density < 5000:
               return 4
           elif population_density < 50000:
               return 5
           else:
               return 6
   ```

3. **Update endpoints to use correct class:**
   ```python
   # Line 250 - SORA 2.0 endpoint
   @app.post("/api/v1/calculate/grc/2.0")
   def calculate_grc_2_0(...):
       result = SORAv2_0_Table2.calculate_initial_grc(mtom_kg, pop_density)
   
   # Line 330 - SORA 2.5 endpoint  
   @app.post("/api/v1/calculate/grc/2.5")
   def calculate_grc_2_5(...):
       result = JARUSSORAv2_5_Table2.calculate_initial_grc(
           dimension_m, speed_ms, pop_density
       )
   ```

4. **Update tests:**
   - SORA 2.0 tests: Use MTOM + population density
   - SORA 2.5 tests: Use dimension + speed + population density

## 4. DETAILED CODE CHANGES

[Specific file edits with exact line numbers and code]

## 5. VALIDATION PLAN

[How to verify the fix is correct]

---
**Analysis Date:** [Date]
**Reviewed By:** Claude Sonnet 4
**Confidence:** 95%
```

## PHASE 4: VERIFICATION (Both Copilot + Sonnet 4)

After implementation:

1. **Copilot runs tests:**
   ```bash
   python test_sora_direct.py
   ```

2. **If tests pass:** ✅ Done!

3. **If tests fail:**
   - Copilot sends test results back to Sonnet 4
   - Sonnet 4 analyzes failures
   - Provides additional corrections
   - Iterate until 100% pass

## SUCCESS CRITERIA

- ✅ All 20 tests pass (10 SORA 2.0 + 10 SORA 2.5)
- ✅ Python backend matches official JARUS specs
- ✅ .NET backend matches official JARUS specs  
- ✅ Clear separation between SORA 2.0 and 2.5 logic
- ✅ Documentation updated with correct Table 2 references

## CURRENT STATUS

- ⏳ Phase 1 (Information Gathering): **COMPLETE**
- ⏳ Phase 2 (Sonnet 4 Analysis): **READY TO START**
- ⏹️ Phase 3 (Implementation): Pending Sonnet 4 response
- ⏹️ Phase 4 (Verification): Pending implementation

## NEXT STEP

**Send this package to Claude Sonnet 4 for detailed analysis.**

---

**Prepared by:** GitHub Copilot  
**Date:** October 29, 2025  
**For:** SKYWORKS AI Suite Development Team


---

## WHAT WE NEED FROM YOU

Please provide a comprehensive analysis with:

### 1. OFFICIAL SPECIFICATION VERIFICATION
- Quote exact Table 2 from JARUS SORA 2.0 official docs
- Quote exact Table 2 from JARUS SORA 2.5 official docs  
- Confirm which structure (MTOM vs Dimension+Speed) belongs to which version

### 2. CODE CORRECTNESS ASSESSMENT
- Is Python backend correct for SORA 2.0? ✅/❌
- Is .NET backend correct for SORA 2.5? ✅/❌
- Line-by-line analysis of discrepancies

### 3. RECOMMENDED SOLUTION
Choose ONE and provide detailed implementation:

**Option A: Dual Implementation**
- Keep both Table 2 versions
- Separate classes: `SORAv2_0_Table2` and `JARUSSORAv2_5_Table2`
- Clear endpoint separation: `/grc/2.0` vs `/grc/2.5`

**Option B: Migrate to SORA 2.5 Only**
- Replace MTOM logic with Dimension+Speed logic
- Deprecate SORA 2.0 endpoints
- Migration guide for existing data

**Option C: Current Code is Correct**
- Tests have wrong expectations
- Just fix test expected values
- Document why values are correct

### 4. DETAILED IMPLEMENTATION PLAN
- Specific file paths to edit
- Exact line numbers to change
- Before/after code snippets
- Updated test expectations
- Verification steps

---

## CRITICAL QUESTIONS

1. **Does SORA 2.0 use MTOM-based Table 2?** (5×4 matrix with weight categories)
2. **Does JARUS SORA 2.5 use Dimension+Speed-based Table 2?** (7×5 matrix)
3. **Are both valid simultaneously?** (Different SORA versions, both correct)
4. **What is the migration path?** (If SORA 2.5 supersedes 2.0)

---

## DELIVERABLES REQUESTED

1. **Table 2 Specification Document** (from official JARUS sources)
2. **Code Analysis Report** (line-by-line review with corrections)
3. **Recommended Solution** (Option A, B, or C with justification)
4. **Implementation Code** (exact Python code changes)
5. **Updated Test Suite** (correct expected values)
6. **Verification Plan** (how to prove fix is correct)

---

**Please provide your analysis with high confidence and cite official JARUS documentation for all claims.**

Thank you!

---
**Prepared by:** GitHub Copilot
**For:** Claude Sonnet 4 Expert Analysis
**Project:** SKYWORKS AI Suite V5
